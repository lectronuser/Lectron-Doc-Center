{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"About Us <p>       We are a passionate team committed to transforming the world through innovative drone and robotics technologies. With a forward-thinking mindset, we push the limits of what\u2019s possible in autonomous systems.Our mission is to deliver practical, high impact solutions for sectors like defense, agriculture, and industry shaping a smarter and more efficient future through bold ideas and agile thinking.     </p> Jetson Raspberry Pi Lectron Jetson Autopilot <p>Jetson Nano / Xavier NX / Orin Nano \u2014 PX4 FMUv6X</p> <ul> <li>GPU-Based Autopilot</li> <li>Dual CSI Camera Support</li> <li>PX4 FMUv6X Integrated</li> <li>Integrated Ethernet Switching</li> </ul> Open Jetson Docs Lectron Pi5 Autopilot <p>CM5 + Hailo Edge AI \u2014 PX4 FMUv6X</p> <ul> <li>Hailo-26 TOPS AI Acceleration</li> <li>Dual CSI Camera Support</li> <li>PX4 FMUv6X Integrated</li> <li>Gigabit Ethernet Ready</li> </ul> Open CM5 Docs"},{"location":"md/jetson/","title":"Lectron Jetson Autopilot","text":"<p>Integrated Flight Control &amp; Edge Computing Platform</p> <p>The Jetson Custom Board is designed as an integrated flight control and computing platform for autonomous systems and advanced embedded applications. The hardware architecture consolidates real-time flight control and high-level computing into a single unified board.</p> <p>This approach simplifies system integration, reduces cabling complexity, and improves overall system reliability.</p>"},{"location":"md/jetson/block-diagram/","title":"Block Diagram","text":""},{"location":"md/jetson/commands/","title":"Commands","text":""},{"location":"md/jetson/commands/#jetson-power-model","title":"Jetson Power Model","text":"<ul> <li><code>sudo nvpmodel -q</code> Displays the current active power mode. Allows you to check which performance profile is currently in use.</li> <li><code>sudo nvpmodel -m0</code> Maximum Performance Mode (MAXN)</li> </ul> <p>Info</p> <p>Enables maximum performance mode, activating all CPU cores and full GPU capability. Recommended for compute-intensive workloads such as YOLO, SLAM, image processing, and autonomous control loops</p> <ul> <li><code>sudo nvpmodel -m1</code> Low Power Mode (5W)</li> </ul> <p>Warning</p> <p>Runs the Jetson in Low Power Mode. Reduces energy consumption but significantly limits performance.</p> <pre><code>sudo nvpmodel -q   # Show current power mode\nsudo nvpmodel -m0  # MAX mode\nsudo nvpmodel -m1  # 5W mode\n</code></pre>"},{"location":"md/jetson/commands/#jetson-temperature-monitoring","title":"Jetson Temperature Monitoring","text":"<ul> <li><code>cat /sys/class/thermal/thermal_zone*/temp</code> Displays raw temperature readings (in millidegrees Celsius) for all available thermal zones.</li> <li><code>cat /sys/class/thermal/thermal_zone*/type</code> Shows the sensor name associated with each thermal zone (e.g., CPU-therm, GPU-therm, Tboard-therm).</li> <li><code>sudo tegrastats</code> Real-time monitoring tool for temperature, CPU/GPU usage, memory, and power consumption.</li> <li><code>watch -n1 'cat /sys/class/thermal/thermal_zone*/temp'</code> Continuously displays updated temperature readings every second.</li> </ul> <p>Info</p> <p>Each Jetson thermal sensor is represented as a thermal zone. Temperature values are reported in millidegrees Celsius (e.g., <code>45000</code> \u2192 45\u00b0C). Use these readings to diagnose thermal throttling, cooling efficiency, and system load behavior.</p> <p>Usage Example</p> <pre><code>cat /sys/class/thermal/thermal_zone1/type\ncat /sys/class/thermal/thermal_zone1/temp\nsudo tegrastats        # real-time monitoring\n</code></pre> <p>Warning</p> <p>High temperatures can cause thermal throttling, reducing CPU/GPU frequencies and impacting performance. Ensure proper cooling for compute-intensive workloads or enclosed environments.</p>"},{"location":"md/jetson/commands/#kernel-debugfs-debugfs-overview","title":"Kernel DebugFS (debugfs) Overview","text":"<ul> <li> <p>The <code>gpio</code> file lists the current state of all GPIO lines in the system. It shows each line\u2019s associated controller (gpiochip), direction (input/output), current value, and usage status. It is one of the most reliable diagnostic sources for verifying which physical pin corresponds to which GPIO line on Jetson platforms. <pre><code>sudo cat /sys/kernel/debug/gpio\n</code></pre></p> </li> <li> <p>The <code>tegra_pinctrl_reg</code> file contains the current pinmux configuration and pin controller register values for all pins on the Jetson platform. It is a critical reference for determining whether each pin is configured as GPIO, I2C, SPI, or another function, and for verifying that hardware configuration has been correctly applied. <pre><code>sudo cat /sys/kernel/debug/tegra_pinctrl_reg\n</code></pre></p> </li> </ul>"},{"location":"md/jetson/commands/#low-level-register-access-with-devmem2","title":"Low-Level Register Access with <code>devmem2</code>","text":"<ul> <li><code>devmem2</code> allows direct access to physical memory from userspace and enables read/write operations on hardware registers. It is mainly used to quickly test memory-mapped I/O (MMIO) registers.</li> </ul> <p>Warning</p> <p>Writing incorrect values to the wrong physical address using <code>devmem2</code> may hang the system, trigger unexpected resets, or cause hardware misbehavior. Use this tool only if you fully understand the register map and have the SoC/Jetson TRM at hand.</p> <p>Example</p> <p>First, you can inspect the <code>tegra_pinctrl_reg</code> contents to understand which register regions are used for a given pin/pad:</p> <pre><code>sudo cat /sys/kernel/debug/tegra_pinctrl_reg\n</code></pre> <p>This output shows the register addresses and values associated with the pinmux/pad configuration for each pin. From here, you can identify the register address or offset used for a specific pin. </p> <pre><code># Read current value\nsudo devmem2 0x[address] w\n\n# Set the address value\nsudo devmem2 0x[address] w 0x1\n</code></pre>"},{"location":"md/jetson/dimension/","title":"Dimension","text":""},{"location":"md/jetson/getting_started/","title":"Getting StartedContent Under Preparation","text":""},{"location":"md/jetson/gpio/","title":"GPIO Control","text":""},{"location":"md/jetson/gpio/#jetson-nano-gpio-to-sysfs-mapping-table","title":"Jetson Nano GPIO to Sysfs Mapping Table","text":"<pre><code>- Pin 28: GPI02 \u2192 62  (sysfs)\n- Pin 34: GPI05 \u2192 63  (sysfs)\n- Pin 36: GPI06 \u2192 64  (sysfs)\n- Pin ..: GPIO4 \u2192 65  (sysfs)\n- Pin ..: GPIO3 \u2192 66  (sysfs)\n- Pin 26: GPI01 \u2192 149 (sysfs)\n- Pin 38: GPI07 \u2192 168 (sysfs)\n- Pin 40: GPI08 \u2192 202 (sysfs)\n- Pin ..: GPI09 \u2192 216 (sysfs)\n</code></pre>"},{"location":"md/jetson/gpio/#what-is-sysfs","title":"What is <code>sysfs</code>?","text":"<p>Linux exposes hardware interfaces under <code>/sys</code> using a special virtual filesystem called sysfs. GPIO, PWM, I2C, SPI and other hardware components appear as simple files inside this structure.</p> <p>Info</p> <p>This allows GPIO pins to be controlled using simple file writes:  <code>export \u2192 direction \u2192 value</code>.</p> <p>Terminal Code Example</p> <p>This example demonstrates how to set GPIO with sysfs ID 79 to HIGH and LOW using the terminal.</p> <pre><code>echo 79 &gt; /sys/class/gpio/export\necho out &gt; /sys/class/gpio/gpio79/direction\necho 1 &gt; /sys/class/gpio/gpio79/value\necho 0 &gt; /sys/class/gpio/gpio79/value\n</code></pre> C (libgpiod)Shell (sysfs) <pre><code>#include &lt;gpiod.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, char *argv[])\n{\n    if (argc != 3) {\n        fprintf(stderr, \"Usage: %s &lt;LINE_OFFSET&gt; &lt;VALUE&gt;\\n\", argv[0]);\n        fprintf(stderr, \"VALUE: 0 (low) or 1 (high)\\n\");\n        return 1;\n    }\n\n    int line_offset = atoi(argv[1]);\n    int value       = atoi(argv[2]);\n\n    if (value != 0 &amp;&amp; value != 1) {\n        fprintf(stderr, \"Error: VALUE must be 0 or 1\\n\");\n        return 1;\n    }\n\n    struct gpiod_chip *chip = gpiod_chip_open_by_name(\"gpiochip3\");\n    if (!chip) {\n        perror(\"gpiod_chip_open_by_name\");\n        return 1;\n    }\n\n    struct gpiod_line *line = gpiod_chip_get_line(chip, line_offset);\n    if (!line) {\n        perror(\"gpiod_chip_get_line\");\n        gpiod_chip_close(chip);\n        return 1;\n    }\n\n    if (gpiod_line_request_output(line, \"gpio_set\", value) &lt; 0) {\n        perror(\"gpiod_line_request_output\");\n        gpiod_chip_close(chip);\n        return 1;\n    }\n\n    gpiod_line_release(line);\n    gpiod_chip_close(chip);\n\n    return 0;\n}\n</code></pre> <pre><code>#!/bin/sh\n\nif [ $# -ne 2 ]; then\n    echo \"Usage: $0 &lt;GPIO_PIN&gt; &lt;VALUE&gt;\"\n    echo \"VALUE: 0 (low) or 1 (high)\"\n    exit 1\nfi\n\nGPIO_PIN=\"$1\"\nVALUE=\"$2\"\n\nif [ \"$VALUE\" != \"0\" ] &amp;&amp; [ \"$VALUE\" != \"1\" ]; then\n    echo \"Error: VALUE must be 0 or 1\"\n    exit 1\nfi\n\nGPIO_PATH=\"/sys/class/gpio/gpio$GPIO_PIN\"\n\nif [ ! -d \"$GPIO_PATH\" ]; then\n    echo \"$GPIO_PIN\" &gt; /sys/class/gpio/export\n    sleep 0.1\nfi\n\necho \"out\" &gt; \"$GPIO_PATH/direction\"\necho \"$VALUE\" &gt; \"$GPIO_PATH/value\"\n</code></pre> <p>Info</p> <p>You can access these codes on Lectron\u2019s GitHub page through this link; the files are named gpio_set.sh and gpio_set.c.</p> <p>Warning</p> <p>If you receive an error stating that <code>&lt;gpiod.h&gt;</code> cannot be found during compilation, it means the <code>libgpiod</code> development packages are not installed on your system. To resolve this issue, install the required packages using:  <code>bash sudo apt-get install -y gpiod libgpiod-dev</code></p>"},{"location":"md/jetson/gpio/#how-to-calculate-the-sysfs-value-from-a-gpio-name","title":"How to Calculate the Sysfs Value from a GPIO Name?","text":"<ul> <li>Download the pinmux configuration file for your specific Jetson module. It is available on NVIDIA\u2019s official documentation page.</li> <li>Inside the downloaded <code>pinmux_config_template.xlsm</code> file, you will find two sheets:<ul> <li>The first sheet contains general notes and explanations.</li> <li>The second sheet (jetson_[xx]_module) lists the GPIO names along with their detailed identifiers (e.g., <code>GPIO3_PI.01</code>).</li> </ul> </li> </ul> <ul> <li>In an identifier such as <code>GPIO3_PI.01</code>:<ul> <li>The letters (e.g., PI, where I is important) correspond to the <code>TEGRA_GPIO_PORT</code> value.</li> <li>The number after the dot (<code>01</code>) represents the pin offset.</li> </ul> </li> <li>The Sysfs GPIO number is computed using the following formula: <code>TEGRA_GPIO = (TEGRA_GPIO_PORT * 8) + pin_offset</code> <ul> <li>You can find this formula in the <code>tegra194-gpio.h</code> header file.</li> </ul> </li> </ul> tegra194-gpio.h<pre><code>#define TEGRA_GPIO(port, offset) \\ ((TEGRA_GPIO_PORT_##port * 8) + offset)\n#define TEGRA_GPIO_PORT_A 0\n#define TEGRA_GPIO_PORT_B 1\n#define TEGRA_GPIO_PORT_C 2\n#define TEGRA_GPIO_PORT_D 3\n#define TEGRA_GPIO_PORT_E 4\n#define TEGRA_GPIO_PORT_F 5\n#define TEGRA_GPIO_PORT_G 6\n#define TEGRA_GPIO_PORT_H 7\n#define TEGRA_GPIO_PORT_I 8\n#define TEGRA_GPIO_PORT_J 9\n#define TEGRA_GPIO_PORT_K 10\n#define TEGRA_GPIO_PORT_L 11\n#define TEGRA_GPIO_PORT_M 12\n#define TEGRA_GPIO_PORT_N 13\n#define TEGRA_GPIO_PORT_O 14\n#define TEGRA_GPIO_PORT_P 15\n#define TEGRA_GPIO_PORT_Q 16\n#define TEGRA_GPIO_PORT_R 17\n#define TEGRA_GPIO_PORT_S 18\n#define TEGRA_GPIO_PORT_T 19\n#define TEGRA_GPIO_PORT_U 20\n#define TEGRA_GPIO_PORT_V 21\n#define TEGRA_GPIO_PORT_W 22\n#define TEGRA_GPIO_PORT_X 23\n#define TEGRA_GPIO_PORT_Y 24\n#define TEGRA_GPIO_PORT_Z 25\n#define TEGRA_GPIO_PORT_AA 26\n#define TEGRA_GPIO_PORT_BB 27\n</code></pre> <ul> <li>After substituting the port index and the pin offset into the formula, you obtain the corresponding sysfs GPIO number.</li> </ul> <p>Example</p> <pre><code>GPIO09 sysfs value is 216\nGPIO09 -&gt; GPIO3_PBB.00\nTEGRA_GPIO_PORT = BB \nOffset = 0\nTEGRA_GPIO = (TEGRA_GPIO_PORT_BB * 8) + 0 -&gt; (27 * 8) + 0 = 216\n</code></pre> <p>Warning</p> <p>This Formula Does NOT Apply to PMIC GPIOs (<code>max77620-gpio</code>) <pre><code>sudo dmesg | grep \"registered GPIO\"\n[    0.534131] gpiochip_setup_dev: registered GPIOs 0 to 255 on device: gpiochip0 (tegra-gpio)\n[    0.591897] gpiochip_setup_dev: registered GPIOs 504 to 511 on device: gpiochip1 (max77620-gpio)\n</code></pre></p> <ul> <li>Jetson platforms have two separate GPIO controllers: <ul> <li>tegra-gpio -&gt; [0-255] On-SoC Tegra GPIOs</li> <li>max77620-gpio -&gt; [504\u2013511]  PMIC GPIOs</li> </ul> </li> <li>If the GPIO belongs to tegra-gpio \u2192 Use Tegra Port Formula.</li> <li>If it belongs to max77620-gpio \u2192 The sysfs number is assigned directly by the kernel and the correct calculation is <code>offset = sysfs_gpio - gpiochip_base   # Example: 509 - 504 = 5</code></li> </ul>"},{"location":"md/jetson/network/","title":"Networking","text":"<p>On Jetson (Ubuntu-based) systems, networking can be controlled by three different mechanisms:</p> <ol> <li>NetworkManager (NM)</li> <li><code>/etc/network/interfaces</code> (ifupdown)</li> <li>Netplan (systemd-networkd or NetworkManager renderer)</li> </ol> <p>Warning</p> <p>These systems can conflict with each other when active simultaneously, often resulting in issues such as: - eth0 being shown as DEVICE -- - NetworkManager being unable to manage Ethernet - Misconfigured profiles being ignored</p>"},{"location":"md/jetson/network/#networkmanager","title":"NetworkManager","text":"<p>The default modern network management system. - Location: <code>/etc/NetworkManager/system-connections/</code> - Requires correct permissions and ownership - Handles Ethernet, Wi-Fi, VPN, DHCP, static IP - If NM does not manage eth0 \u2192 Connection appears as <code>DEVICE --</code></p>"},{"location":"md/jetson/network/#creating-a-fresh-eth0-profile-recommended","title":"Creating a Fresh eth0 Profile (Recommended)","text":"<pre><code># Delete old profile (ignore errors)\nsudo nmcli connection delete eth0\n\n# Create a new DHCP profile\nsudo nmcli connection add type ethernet ifname eth0 con-name eth0 ipv4.method auto ipv6.method ignore\n\n# Fix permissions\n# Without these, NetworkManager can see the profile but cannot activate it.\nsudo chmod 600 /etc/NetworkManager/system-connections/eth0\nsudo chown root:root /etc/NetworkManager/system-connections/eth0\n\n# Restart NM\nsudo nmcli connection reload\nsudo systemctl restart NetworkManager\n\n# Bring up the interface\nsudo nmcli connection down eth0\nsudo nmcli connection up eth0\n\n# Verify assigned IP\nip addr show eth0\n</code></pre>"},{"location":"md/jetson/network/#static-setup","title":"Static Setup","text":"<pre><code>    sudo nano /etc/NetworkManager/system-connections/eth0\n</code></pre> <pre><code>[connection]\nid=eth0\ntype=ethernet\ninterface-name=eth0\npermissions=\n\n[ethernet]\nmac-address-blacklist=\n\n[ipv4]\naddress1=192.168.1.3/24\ndns-search=\nmethod=manual\n\n[ipv6]\nmethod=ignore\n</code></pre>"},{"location":"md/jetson/network/#dhcp-setup","title":"DHCP Setup","text":"<pre><code>    sudo nano /etc/NetworkManager/system-connections/eth0\n</code></pre> <pre><code>[connection]\nid=eth0\ntype=ethernet\ninterface-name=eth0\nautoconnect=true\n\n[ipv4]\nmethod=auto\n\n[ipv6]\nmethod=ignore\n</code></pre> <p>What <code>DEVICE -</code> Means (eth0 Not Connecting)</p> <p>This indicates: NetworkManager sees the connection profile but cannot bind it to the actual eth0 interface. On Jetson devices, the eth0 interface may be managed by a different legacy configuration mechanism compared to other network interfaces. If <code>/etc/network/interfaces</code> contains an old-style configuration entry for eth0, NetworkManager will stop managing this interface, causing it to appear as <code>DEVICE --</code> in nmcli. To resolve this, comment out or remove the eth0 lines in the interfaces file. Once these entries are disabled, NetworkManager will correctly take control of the eth0 interface, and the connection will function as expected.</p>"},{"location":"md/jetson/network/#ifupdown","title":"ifupdown","text":"<p>Legacy networking method. If this file contains:</p> <ul> <li>Location: <code>/etc/network/interfaces</code></li> </ul> <pre><code>auto eth0\niface eth0 inet dhcp\n</code></pre> <ul> <li>Then:<ul> <li>NetworkManager will NOT manage eth0</li> <li>eth0 becomes unmanaged</li> <li>nmcli shows <code>DEVICE --</code></li> </ul> </li> </ul> <pre><code>auto lo\niface lo inet loopback\n</code></pre>"},{"location":"md/jetson/network/#netplan","title":"Netplan","text":"<ul> <li>Installing Netplan (if missing): <code>sudo apt install netplan.io</code></li> <li>Controls which backend manages the network: <ul> <li><code>renderer: NetworkManager</code></li> <li><code>renderer: networkd</code></li> </ul> </li> <li>Location: <code>/etc/netplan/*.yaml</code></li> </ul> <pre><code>network:\n  version: 2\n  renderer: NetworkManager\n  ethernets:\n      enp2s0:\n          addresses:\n              - 192.168.2.1/16\n          nameservers:\n              addresses: [192.168.2.1]\n          routes:\n              - to: 192.168.2.1\n                via: 192.168.2.1\n</code></pre> <pre><code>sudo netplan try\nsudo netplan apply\n</code></pre> <ul> <li>Netplan Network Configuration</li> </ul>"},{"location":"md/jetson/pinout/","title":"PinoutContent Under Preparation","text":""},{"location":"md/jetson/setup/","title":"Setup","text":"<p>This document describes the Linux for Tegra (L4T) installation process for a custom Jetson Nano based carrier board. The packages used are derived from NVIDIA\u2019s official releases and adapted to support board specific hardware components.</p> <p>Note</p> <p>The steps are written for Jetson Nano. The same procedure applies to other Jetson models; only the Ubuntu version and package names differ.</p>"},{"location":"md/jetson/setup/#requirements","title":"Requirements","text":"<ol> <li>Jetson-210_Linux_R32.7.6_aarch64.tbz2</li> <li>Tegra_Linux_Sample-Root-Filesystem_R32.7.6_aarch64.tbz2</li> <li>Host system:<ul> <li>Ubuntu 18.04</li> <li>Or Ubuntu 18.04 running inside Docker</li> </ul> </li> </ol> <p>Info</p> <p>By default, the installation is performed under a <code>workspace</code> directory in the user\u2019s home path. A custom directory may be used if preferred</p> <ol> <li> <p>Extracting the L4T Package: Create the workspace and extract the L4T package (This will create the Linux_for_Tegra directory.) <pre><code>mkdir ~/workspace\ncd ~/workspace\ntar xf Jetson-210_Linux_R32.7.6_aarch64.tbz2\n</code></pre></p> </li> <li> <p>Installing the Root Filesystem: Extract the root filesystem into the rootfs directory: <pre><code>cd ~/workspace/Linux_for_Tegra/rootfs\nsudo tar xpf ../../Tegra_Linux_Sample-Root-Filesystem_R32.7.6_aarch64.tbz2\n</code></pre></p> </li> <li> <p>Applying NVIDIA Binary Files: Run the following script to install NVIDIA-specific binaries into the root filesystem <pre><code>cd ~/workspace/Linux_for_Tegra\nsudo ./apply_binaries.sh\n</code></pre></p> </li> <li> <p>Verifying the Installation: Verify that the base system was created successfully. (If the file exists, the setup is valid.) <pre><code>ls -l rootfs/etc/nv_tegra_release\n</code></pre></p> </li> <li> <p>Creating a Default User: To predefine the default user credentials (<code>-u</code>: Username, <code>-p</code>: Password, <code>-n</code>: Hostname) <pre><code>cd ~/workspace/Linux_for_Tegra\n\nsudo ./tools/l4t_create_default_user.sh \\\n  -u ems \\                                       \n  -p '1234!' \\\n  -n lectorn\n</code></pre></p> </li> <li> <p>Entering Force Recovery Mode (RCM):  To flash the device, Jetson Nano must be placed into Force Recovery Mode (RCM).</p> <ul> <li>Press and hold Recovery and Reset pins together</li> <li>Wait 15\u201330 seconds</li> <li>Release Reset first</li> <li>Then release Recovery</li> <li>Connect the board to the host PC via USB Type-B and verify: <code>lsusb</code> If NVIDIA Corp. appears, the device is ready for flashing.</li> </ul> </li> <li> <p>Flashing the Device: <pre><code>cd ~/workspace/Linux_for_Tegra\nsudo ./flash.sh lectron-nano-emmc mmcblk0p1\n</code></pre></p> </li> </ol>"},{"location":"md/jetson/specification/","title":"Specification","text":""},{"location":"md/jetson/specification/#jetson-system-support","title":"Jetson &amp; System Support","text":"Feature Description Supported Jetson Modules Jetson Nano, Xavier NX, AGX Xavier, Orin SoM Connector 260-Pin DDR4 SODIMM Power Regulation Dedicated 5.1 V \u2013 5 A rail Cooling Active &amp; passive advanced rail cooling Camera Interface 2 \u00d7 15-Pin, 1 mm pitch CSI USB USB 3.0 Type-C (2 A), USB 2.0 Mini-B Debug Debug UART, Force Recovery &amp; Reset Ethernet 2 \u00d7 4-Pin, 100 Mbps GPIO 1 \u00d7 10-Pin I2C 2 \u00d7 4-Pin (isolated buses) UART 1 \u00d7 4-Pin (isolated buses) CAN 1 \u00d7 4-Pin SPI 1 \u00d7 6-Pin"},{"location":"md/jetson/specification/#pixhawk-system-support","title":"Pixhawk &amp; System Support","text":"Feature Description Supported Autopilots Pixhawk 5X, Pixhawk 6X Power Regulation Dedicated 5.1 V \u2013 3 A rail Power Distribution Onboard regulated Ethernet Embedded 100 Mbps Port Compatibility Pixhawk &amp; Jetson standards Cooling Designed for heavy workloads Main Connectors 100-Pin &amp; 50-Pin Hirose DF40 TELEM 2 \u00d7 6-Pin GPS Full (10-Pin), Basic (6-Pin) CAN 1 \u00d7 4-Pin I2C 1 \u00d7 4-Pin UART 1 \u00d7 4-Pin RC / SBUS 1 \u00d7 5-Pin PWM AUX &amp; MAIN, 10-Pin Ethernet 1 \u00d7 4-Pin Debug FMU-IO Debug, 11-Pin (SH) Jetson Link UART or Ethernet"},{"location":"md/jetson/specification/#power-architecture","title":"Power Architecture","text":"Feature Description Power-In XT30 with reverse protection, soft-start Input Voltage 10 \u2013 35 VDC (XT30) Bulk Capacitor 220 \u00b5F 5.0 V Rail 5.0 V \u2013 3 A (Pixhawk &amp; outputs) 5.1 V Rail 5.1 V \u2013 5 A (Jetson &amp; peripherals) 12 V Rail 12 V \u2013 2 A (sensors/actuators) Protection Over-current &amp; short-circuit sensing Battery Monitoring Input voltage sensing"},{"location":"md/jetson/specification/#thermal-management","title":"Thermal Management","text":"Feature Description Fans 2 \u00d7 12 VDC, 12 W Intake Blower Fan Control Jetson fan framework or On/Off Airflow Forced convection over heat-sink"},{"location":"md/raspberry/","title":"Lectron Pi5 Autopilot","text":"<p>The Raspberry CM5 Board is designed as an integrated flight control and computing platform for autonomous systems and advanced embedded applications. The hardware architecture consolidates real-time flight control and high-level computing into a single unified board.</p> <p>This approach simplifies system integration, reduces cabling complexity, and improves overall system reliability.</p>"},{"location":"md/raspberry/block-diagram/","title":"Block Diagram","text":""},{"location":"md/raspberry/dimension/","title":"DimensionContent Under Preparation","text":""},{"location":"md/raspberry/getting_started/","title":"Getting StartedContent Under Preparation","text":""},{"location":"md/raspberry/gpio/","title":"PinoutContent Under Preparation","text":""},{"location":"md/raspberry/network/","title":"PinoutContent Under Preparation","text":""},{"location":"md/raspberry/pinout/","title":"PinoutContent Under Preparation","text":""},{"location":"md/raspberry/setup/","title":"Setup","text":"<p>To flash the eMMC on a Raspberry Pi Compute Module, the following components are required:</p> <ul> <li>Host device: A computer running Linux, Windows, or macOS</li> <li>Micro USB cable</li> <li>Raspberry Pi Compute Module with a compatible carrier board</li> </ul>"},{"location":"md/raspberry/setup/#set-up-the-board","title":"Set up the Board","text":"<ul> <li>To disable eMMC boot on the Raspberry Pi: Set the nRPI_BOOT pin to HIGH using the 8-pin DIP switch on the board (typically the 3rd switch).</li> <li>Connect the board to the host device using a Micro USB cable.</li> </ul>"},{"location":"md/raspberry/setup/#set-up-the-host-device","title":"Set up the Host Device","text":"<p>Note</p> <p>The steps below follow the official Raspberry Pi documentation without modification. Reference: Raspberry Pi \u2013 eMMC flashing documentation</p> LinuxWindowsMacOS <ol> <li>Install the rpiboot tool (or build it from source): <code>sudo apt install rpiboot</code></li> <li>Connect the IO Board to power.</li> <li>Run rpiboot: <code>sudo rpiboot</code></li> <li>After a few seconds, the Compute Module will appear as a USB mass storage device.<ul> <li>Check <code>/dev/</code> (commonly <code>/dev/sda</code> or <code>/dev/sdb</code>)</li> <li>Alternatively, run lsblk and identify the device matching the module\u2019s storage size.</li> </ul> </li> </ol> <ol> <li>Download the Windows installer for rpiboot or build it from source.</li> <li>Run the installer. (Do not close any driver installation windows during setup.)</li> <li>Reboot the system.</li> <li>Connect the IO Board to power. Windows will automatically detect the hardware and install required drivers.</li> <li>For CM4 and newer devices:<ul> <li>Select \u201cRaspberry Pi \u2013 Mass Storage Gadget \u2013 64-bit\u201d from the Start Menu.</li> <li>The eMMC or NVMe device will appear as a USB mass storage device.</li> <li>A serial debug console is also exposed.</li> </ul> </li> <li>For CM3 and older devices:<ul> <li>Run RPiBoot.exe.</li> <li>The Compute Module eMMC will appear as a USB mass storage device.</li> </ul> </li> </ol> <ol> <li>Build rpiboot from source.</li> <li>Connect the IO Board to power.</li> <li>Run the rpiboot executable from the terminal: <code>rpiboot -d mass-storage-gadget64</code></li> <li>When prompted with \u201cThe disk you inserted was not readable by this computer.\u201d Click Ignore.</li> <li>The Compute Module eMMC will now appear as a USB mass storage device.</li> </ol> <p>rpiboot</p> <p>The output of the <code>sudo rpiboot</code> command should appear as expected.  If it remains stuck at <code>Waiting for BCM2835/6/7/2711/2712...</code>,  install rpiboot from source..</p> <p></p>"},{"location":"md/raspberry/setup/#raspberry-pi-imager","title":"Raspberry Pi Imager","text":"<ul> <li>Launch the Raspberry Pi Imager application.</li> <li>Select Raspberry Pi 5 as the target board.</li> </ul> <ul> <li>Choose the operating system; Raspberry Pi OS (64-bit) is recommended.</li> </ul> <ul> <li>As the storage device, select the Raspberry Pi eMMC detected by your computer.</li> </ul> <ul> <li>In the advanced settings section, configure: Username, Hostname, Wi-Fi credentials, SSH access</li> </ul> <ul> <li>Start the flashing process by clicking <code>Write</code> and wait until it completes.</li> </ul> <p>Note</p> <ul> <li>After the installation is completed, make sure to set pin 3 on the 8-pin DIP switch back to the LOW state.</li> <li>Before performing this step, power off the device.</li> <li>Disconnect the Micro USB cable.</li> <li>Set pin 3 of the DIP switch to the LOW position.</li> <li>Finally, reconnect the power supply to restart the system.</li> </ul>"},{"location":"md/raspberry/specification/","title":"Specification","text":""},{"location":"md/raspberry/specification/#cm5-system-support","title":"CM5 &amp; System Support","text":"Feature Description Supported Raspberry Modules Compute Module 5 Camera Interface 2 \u00d7 22-Pin, 0.5 mm pitch CSI USB USB 3.0 Type-C (2 A), Micro USB 2.0 Ethernet 1 \u00d7 4-Pin, 1 Gbps GPIO 1 \u00d7 6-Pin I2C 2 UART 1 CAN 1 \u00d7 4-Pin SPI 1"},{"location":"md/raspberry/specification/#pixhawk-system-support","title":"Pixhawk &amp; System Support","text":"Feature Description Supported Autopilots Pixhawk 5X, Pixhawk 6X Power Regulation Dedicated 5.1 V \u2013 3 A rail Power Distribution Onboard regulated Cooling Designed for heavy workloads TELEM 2 \u00d7 6-Pin GPS Full (10-Pin), Basic (6-Pin) CAN 1 \u00d7 4-Pin I2C 1 \u00d7 4-Pin UART 1 \u00d7 4-Pin RC / SBUS 1 \u00d7 5-Pin PWM AUX &amp; MAIN, 10-Pin Ethernet 1 \u00d7 4-Pin Debug FMU-IO Debug, 11-Pin (SH) Jetson Link UART or Ethernet"}]}