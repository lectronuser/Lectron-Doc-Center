{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Lectron","text":"<p>You have accessed the Lectron documentation portal. For more information about our products and solutions, please visit our official lectron website.</p>"},{"location":"md/Jetson/","title":"Jetson Custom Board","text":""},{"location":"md/Jetson/#commands","title":"Commands","text":""},{"location":"md/Jetson/#jetson-power-model","title":"Jetson Power Model","text":"<ul> <li><code>sudo nvpmodel -q</code> Displays the current active power mode. Allows you to check which performance profile is currently in use.</li> <li><code>sudo nvpmodel -m0</code> Maximum Performance Mode (MAXN)</li> </ul> <p>Info</p> <p>Enables maximum performance mode, activating all CPU cores and full GPU capability. Recommended for compute-intensive workloads such as YOLO, SLAM, image processing, and autonomous control loops</p> <ul> <li><code>sudo nvpmodel -m1</code> Low Power Mode (5W)</li> </ul> <p>Warning</p> <p>Runs the Jetson in Low Power Mode. Reduces energy consumption but significantly limits performance.</p> <pre><code>sudo nvpmodel -q   # Show current power mode\nsudo nvpmodel -m0  # MAX mode\nsudo nvpmodel -m1  # 5W mode\n</code></pre>"},{"location":"md/Jetson/#jetson-temperature-monitoring","title":"Jetson Temperature Monitoring","text":"<ul> <li><code>cat /sys/class/thermal/thermal_zone*/temp</code> Displays raw temperature readings (in millidegrees Celsius) for all available thermal zones.</li> <li><code>cat /sys/class/thermal/thermal_zone*/type</code> Shows the sensor name associated with each thermal zone (e.g., CPU-therm, GPU-therm, Tboard-therm).</li> <li><code>sudo tegrastats</code> Real-time monitoring tool for temperature, CPU/GPU usage, memory, and power consumption.</li> <li><code>watch -n1 'cat /sys/class/thermal/thermal_zone*/temp'</code> Continuously displays updated temperature readings every second.</li> </ul> <p>Info</p> <p>Each Jetson thermal sensor is represented as a thermal zone. Temperature values are reported in millidegrees Celsius (e.g., <code>45000</code> \u2192 45\u00b0C). Use these readings to diagnose thermal throttling, cooling efficiency, and system load behavior.</p> <p>Usage Example</p> <pre><code>cat /sys/class/thermal/thermal_zone1/type\ncat /sys/class/thermal/thermal_zone1/temp\nsudo tegrastats        # real-time monitoring\n</code></pre> <p>Warning</p> <p>High temperatures can cause thermal throttling, reducing CPU/GPU frequencies and impacting performance. Ensure proper cooling for compute-intensive workloads or enclosed environments.</p>"},{"location":"md/Jetson/#kernel-debugfs-debugfs-overview","title":"Kernel DebugFS (debugfs) Overview","text":"<ul> <li> <p>The <code>gpio</code> file lists the current state of all GPIO lines in the system. It shows each line\u2019s associated controller (gpiochip), direction (input/output), current value, and usage status. It is one of the most reliable diagnostic sources for verifying which physical pin corresponds to which GPIO line on Jetson platforms. <pre><code>sudo cat /sys/kernel/debug/gpio\n</code></pre></p> </li> <li> <p>The <code>tegra_pinctrl_reg</code> file contains the current pinmux configuration and pin controller register values for all pins on the Jetson platform. It is a critical reference for determining whether each pin is configured as GPIO, I2C, SPI, or another function, and for verifying that hardware configuration has been correctly applied. <pre><code>sudo cat /sys/kernel/debug/tegra_pinctrl_reg\n</code></pre></p> </li> </ul>"},{"location":"md/Jetson/#low-level-register-access-with-devmem2","title":"Low-Level Register Access with <code>devmem2</code>","text":"<ul> <li><code>devmem2</code> allows direct access to physical memory from userspace and enables read/write operations on hardware registers. It is mainly used to quickly test memory-mapped I/O (MMIO) registers.</li> </ul> <p>Warning</p> <p>Writing incorrect values to the wrong physical address using <code>devmem2</code> may hang the system, trigger unexpected resets, or cause hardware misbehavior. Use this tool only if you fully understand the register map and have the SoC/Jetson TRM at hand.</p> <p>Example</p> <p>First, you can inspect the <code>tegra_pinctrl_reg</code> contents to understand which register regions are used for a given pin/pad:</p> <pre><code>sudo cat /sys/kernel/debug/tegra_pinctrl_reg\n</code></pre> <p>This output shows the register addresses and values associated with the pinmux/pad configuration for each pin. From here, you can identify the register address or offset used for a specific pin. </p> <pre><code># Read current value\nsudo devmem2 0x[address] w\n\n# Set the address value\nsudo devmem2 0x[address] w 0x1\n</code></pre>"},{"location":"md/Jetson/#gpio-control","title":"GPIO Control","text":""},{"location":"md/Jetson/#jetson-nano-gpio-to-sysfs-mapping-table","title":"Jetson Nano GPIO to Sysfs Mapping Table","text":"<pre><code>- Pin 28: GPI02 \u2192 62  (sysfs)\n- Pin 34: GPI05 \u2192 63  (sysfs)\n- Pin 36: GPI06 \u2192 64  (sysfs)\n- Pin ..: GPIO4 \u2192 65  (sysfs)\n- Pin ..: GPIO3 \u2192 66  (sysfs)\n- Pin 26: GPI01 \u2192 149 (sysfs)\n- Pin 38: GPI07 \u2192 168 (sysfs)\n- Pin 40: GPI08 \u2192 202 (sysfs)\n- Pin ..: GPI09 \u2192 216 (sysfs)\n</code></pre>"},{"location":"md/Jetson/#what-is-sysfs","title":"What is <code>sysfs</code>?","text":"<p>Linux exposes hardware interfaces under <code>/sys</code> using a special virtual filesystem called sysfs. GPIO, PWM, I2C, SPI and other hardware components appear as simple files inside this structure.</p> <p>Info</p> <p>This allows GPIO pins to be controlled using simple file writes:  <code>export \u2192 direction \u2192 value</code>.</p> <p>Terminal Code Example</p> <p>This example demonstrates how to set GPIO with sysfs ID 79 to HIGH and LOW using the terminal.</p> <pre><code>echo 79 &gt; /sys/class/gpio/export\necho out &gt; /sys/class/gpio/gpio79/direction\necho 1 &gt; /sys/class/gpio/gpio79/value\necho 0 &gt; /sys/class/gpio/gpio79/value\n</code></pre> C (libgpiod)Shell (sysfs) <pre><code>#include &lt;gpiod.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, char *argv[])\n{\n    if (argc != 3) {\n        fprintf(stderr, \"Usage: %s &lt;LINE_OFFSET&gt; &lt;VALUE&gt;\\n\", argv[0]);\n        fprintf(stderr, \"VALUE: 0 (low) or 1 (high)\\n\");\n        return 1;\n    }\n\n    int line_offset = atoi(argv[1]);\n    int value       = atoi(argv[2]);\n\n    if (value != 0 &amp;&amp; value != 1) {\n        fprintf(stderr, \"Error: VALUE must be 0 or 1\\n\");\n        return 1;\n    }\n\n    struct gpiod_chip *chip = gpiod_chip_open_by_name(\"gpiochip3\");\n    if (!chip) {\n        perror(\"gpiod_chip_open_by_name\");\n        return 1;\n    }\n\n    struct gpiod_line *line = gpiod_chip_get_line(chip, line_offset);\n    if (!line) {\n        perror(\"gpiod_chip_get_line\");\n        gpiod_chip_close(chip);\n        return 1;\n    }\n\n    if (gpiod_line_request_output(line, \"gpio_set\", value) &lt; 0) {\n        perror(\"gpiod_line_request_output\");\n        gpiod_chip_close(chip);\n        return 1;\n    }\n\n    gpiod_line_release(line);\n    gpiod_chip_close(chip);\n\n    return 0;\n}\n</code></pre> <pre><code>#!/bin/sh\n\nif [ $# -ne 2 ]; then\n    echo \"Usage: $0 &lt;GPIO_PIN&gt; &lt;VALUE&gt;\"\n    echo \"VALUE: 0 (low) or 1 (high)\"\n    exit 1\nfi\n\nGPIO_PIN=\"$1\"\nVALUE=\"$2\"\n\nif [ \"$VALUE\" != \"0\" ] &amp;&amp; [ \"$VALUE\" != \"1\" ]; then\n    echo \"Error: VALUE must be 0 or 1\"\n    exit 1\nfi\n\nGPIO_PATH=\"/sys/class/gpio/gpio$GPIO_PIN\"\n\nif [ ! -d \"$GPIO_PATH\" ]; then\n    echo \"$GPIO_PIN\" &gt; /sys/class/gpio/export\n    sleep 0.1\nfi\n\necho \"out\" &gt; \"$GPIO_PATH/direction\"\necho \"$VALUE\" &gt; \"$GPIO_PATH/value\"\n</code></pre> <p>Info</p> <p>You can access these codes on Lectron\u2019s GitHub page through this link; the files are named gpio_set.sh and gpio_set.c.</p> <p>Warning</p> <p>If you receive an error stating that <code>&lt;gpiod.h&gt;</code> cannot be found during compilation, it means the <code>libgpiod</code> development packages are not installed on your system. To resolve this issue, install the required packages using:  <code>bash sudo apt-get install -y gpiod libgpiod-dev</code></p>"},{"location":"md/Jetson/#how-to-calculate-the-sysfs-value-from-a-gpio-name","title":"How to Calculate the Sysfs Value from a GPIO Name?","text":"<ul> <li>Download the pinmux configuration file for your specific Jetson module. It is available on NVIDIA\u2019s official documentation page.</li> <li>Inside the downloaded <code>pinmux_config_template.xlsm</code> file, you will find two sheets:<ul> <li>The first sheet contains general notes and explanations.</li> <li>The second sheet (jetson_[xx]_module) lists the GPIO names along with their detailed identifiers (e.g., <code>GPIO3_PI.01</code>).</li> </ul> </li> </ul> <ul> <li>In an identifier such as <code>GPIO3_PI.01</code>:<ul> <li>The letters (e.g., PI, where I is important) correspond to the <code>TEGRA_GPIO_PORT</code> value.</li> <li>The number after the dot (<code>01</code>) represents the pin offset.</li> </ul> </li> <li>The Sysfs GPIO number is computed using the following formula: <code>TEGRA_GPIO = (TEGRA_GPIO_PORT * 8) + pin_offset</code> <ul> <li>You can find this formula in the <code>tegra194-gpio.h</code> header file.</li> </ul> </li> </ul> tegra194-gpio.h<pre><code>#define TEGRA_GPIO(port, offset) \\ ((TEGRA_GPIO_PORT_##port * 8) + offset)\n#define TEGRA_GPIO_PORT_A 0\n#define TEGRA_GPIO_PORT_B 1\n#define TEGRA_GPIO_PORT_C 2\n#define TEGRA_GPIO_PORT_D 3\n#define TEGRA_GPIO_PORT_E 4\n#define TEGRA_GPIO_PORT_F 5\n#define TEGRA_GPIO_PORT_G 6\n#define TEGRA_GPIO_PORT_H 7\n#define TEGRA_GPIO_PORT_I 8\n#define TEGRA_GPIO_PORT_J 9\n#define TEGRA_GPIO_PORT_K 10\n#define TEGRA_GPIO_PORT_L 11\n#define TEGRA_GPIO_PORT_M 12\n#define TEGRA_GPIO_PORT_N 13\n#define TEGRA_GPIO_PORT_O 14\n#define TEGRA_GPIO_PORT_P 15\n#define TEGRA_GPIO_PORT_Q 16\n#define TEGRA_GPIO_PORT_R 17\n#define TEGRA_GPIO_PORT_S 18\n#define TEGRA_GPIO_PORT_T 19\n#define TEGRA_GPIO_PORT_U 20\n#define TEGRA_GPIO_PORT_V 21\n#define TEGRA_GPIO_PORT_W 22\n#define TEGRA_GPIO_PORT_X 23\n#define TEGRA_GPIO_PORT_Y 24\n#define TEGRA_GPIO_PORT_Z 25\n#define TEGRA_GPIO_PORT_AA 26\n#define TEGRA_GPIO_PORT_BB 27\n</code></pre> <ul> <li>After substituting the port index and the pin offset into the formula, you obtain the corresponding sysfs GPIO number.</li> </ul> <p>Example</p> <pre><code>GPIO09 sysfs value is 216\nGPIO09 -&gt; GPIO3_PBB.00\nTEGRA_GPIO_PORT = BB \nOffset = 0\nTEGRA_GPIO = (TEGRA_GPIO_PORT_BB * 8) + 0 -&gt; (27 * 8) + 0 = 216\n</code></pre> <p>Warning</p> <p>This Formula Does NOT Apply to PMIC GPIOs (<code>max77620-gpio</code>) <pre><code>sudo dmesg | grep \"registered GPIO\"\n[    0.534131] gpiochip_setup_dev: registered GPIOs 0 to 255 on device: gpiochip0 (tegra-gpio)\n[    0.591897] gpiochip_setup_dev: registered GPIOs 504 to 511 on device: gpiochip1 (max77620-gpio)\n</code></pre></p> <ul> <li>Jetson platforms have two separate GPIO controllers: <ul> <li>tegra-gpio -&gt; [0-255] On-SoC Tegra GPIOs</li> <li>max77620-gpio -&gt; [504\u2013511]  PMIC GPIOs</li> </ul> </li> <li>If the GPIO belongs to tegra-gpio \u2192 Use Tegra Port Formula.</li> <li>If it belongs to max77620-gpio \u2192 The sysfs number is assigned directly by the kernel and the correct calculation is <code>offset = sysfs_gpio - gpiochip_base   # Example: 509 - 504 = 5</code></li> </ul>"},{"location":"md/Jetson/#networking","title":"Networking","text":"<p>Network settings on Jetson devices are managed by NetworkManager. Below are two example configurations for the eth0 interface:</p> <p>Note</p> <p>These files are typically located under: <pre><code>/etc/NetworkManager/system-connections/\n</code></pre> All changes require restarting the network connection.</p>"},{"location":"md/Jetson/#static-setup","title":"Static Setup","text":"<pre><code>    sudo nano /etc/NetworkManager/system-connections/eth0\n</code></pre> <pre><code>[connection]\nid=eth0\ntype=ethernet\ninterface-name=eth0\npermissions=\n\n[ethernet]\nmac-address-blacklist=\n\n[ipv4]\naddress1=192.168.1.3/24\ndns-search=\nmethod=manual\n\n[ipv6]\nmethod=ignore\n</code></pre>"},{"location":"md/Jetson/#dhcp-setup","title":"DHCP Setup","text":"<pre><code>    sudo nano /etc/NetworkManager/system-connections/eth0\n</code></pre> <pre><code>[connection]\nid=ethernet\ntype=ethernet\nautoconnect=true\ninterface-name=eth0\n\n[ipv4]\nmethod=auto\n\n[ipv6]\nmethod=ignore\n</code></pre>"},{"location":"md/Jetson/#applying-and-restarting-network-settings","title":"Applying and Restarting Network Settings","text":"<pre><code># Reload connection profiles\nsudo nmcli connection reload\n\n# Restart the connection\nsudo nmcli connection down eth0\nsudo nmcli connection up eth0\n\n# Restart NetworkManager (if needed)\nsudo systemctl restart NetworkManager\n\n# Verify assigned IP\nip addr show eth0\n</code></pre>"}]}